// Code generated by Signare OpenAPI generator. DO NOT EDIT

package httpinfra

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"github.com/hyperledger-labs/signare/app/pkg/infra/httpinfra"

	"github.com/hyperledger-labs/signare/app/pkg/commons/logger"

	"github.com/gorilla/mux"
)

// ApplicationAPIHTTPHandler functionality to handle ApplicationAPI HTTP requests
type ApplicationAPIHTTPHandler interface {

	// HandleHTTPApplicationAccountsCreate handles an ApplicationAccountsCreate request
	HandleHTTPApplicationAccountsCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationAccountsRemove handles an ApplicationAccountsRemove request
	HandleHTTPApplicationAccountsRemove(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationUsersCreate handles an ApplicationUsersCreate request
	HandleHTTPApplicationUsersCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationUsersDescribe handles an ApplicationUsersDescribe request
	HandleHTTPApplicationUsersDescribe(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationUsersEdit handles an ApplicationUsersEdit request
	HandleHTTPApplicationUsersEdit(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationUsersList handles an ApplicationUsersList request
	HandleHTTPApplicationUsersList(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPApplicationUsersRemove handles an ApplicationUsersRemove request
	HandleHTTPApplicationUsersRemove(responseWriter http.ResponseWriter, request *http.Request)
}

type ApplicationAPIAdapter interface {
	AdaptApplicationAccountsCreate(ctx context.Context, data ApplicationAccountsCreateRequest) (*ApplicationAccountsCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationAccountsRemove(ctx context.Context, data ApplicationAccountsRemoveRequest) (*ApplicationAccountsRemoveResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationUsersCreate(ctx context.Context, data ApplicationUsersCreateRequest) (*ApplicationUsersCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationUsersDescribe(ctx context.Context, data ApplicationUsersDescribeRequest) (*ApplicationUsersDescribeResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationUsersEdit(ctx context.Context, data ApplicationUsersEditRequest) (*ApplicationUsersEditResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationUsersList(ctx context.Context, data ApplicationUsersListRequest) (*ApplicationUsersListResponseWrapper, *httpinfra.HTTPError)

	AdaptApplicationUsersRemove(ctx context.Context, data ApplicationUsersRemoveRequest) (*ApplicationUsersRemoveResponseWrapper, *httpinfra.HTTPError)
}

var _ ApplicationAPIHTTPHandler = (*DefaultApplicationAPIHTTPHandler)(nil)

// DefaultApplicationAPIHTTPHandler implementation of ApplicationAPIHTTPHandler
type DefaultApplicationAPIHTTPHandler struct {
	adapter         ApplicationAPIAdapter
	responseHandler httpinfra.HTTPResponseHandler
}

// DefaultApplicationAPIHTTPHandlerOptions options to create a DefaultApplicationAPIHTTPHandler
type DefaultApplicationAPIHTTPHandlerOptions struct {
	Adapter         ApplicationAPIAdapter
	ResponseHandler httpinfra.HTTPResponseHandler
}

// NewDefaultApplicationAPIHTTPHandler returns a new DefaultApplicationAPIHTTPHandler
func NewDefaultApplicationAPIHTTPHandler(options DefaultApplicationAPIHTTPHandlerOptions) (*DefaultApplicationAPIHTTPHandler, error) {
	if options.Adapter == nil {
		return nil, errors.New("adapter field is mandatory")
	}
	if options.ResponseHandler == nil {
		return nil, errors.New("responseHandler field is mandatory")
	}

	return &DefaultApplicationAPIHTTPHandler{
		adapter:         options.Adapter,
		responseHandler: options.ResponseHandler,
	}, nil

}

// ApplicationAccountsCreateSupportedParams ApplicationAccountsCreate supported parameters
type ApplicationAccountsCreateSupportedParams struct {
	params map[string]bool
}

// NewApplicationAccountsCreateSupportedParams returns a new ApplicationAccountsCreateSupportedParams
func NewApplicationAccountsCreateSupportedParams() ApplicationAccountsCreateSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["userId"] = true
	params["AccountCreation"] = true
	return ApplicationAccountsCreateSupportedParams{
		params: params,
	}
}

func (sp *ApplicationAccountsCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationAccountsCreate handles ApplicationAccountsCreate request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationAccountsCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationAccountsCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	userIdRawValue := params["userId"]
	// Conversions

	userIdValue := userIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	accountCreationValue := AccountCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&accountCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	accountCreationValidationResult, accountCreationValidationErr := accountCreationValue.ValidateWith()

	if accountCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, accountCreationValidationErr)
		return
	}

	if !accountCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, accountCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	accountCreationValue.SetDefaults()
	reqData := ApplicationAccountsCreateRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserId = userIdValue
	reqData.AccountCreation = accountCreationValue

	response, adaptError := handler.adapter.AdaptApplicationAccountsCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}

// ApplicationAccountsRemoveSupportedParams ApplicationAccountsRemove supported parameters
type ApplicationAccountsRemoveSupportedParams struct {
	params map[string]bool
}

// NewApplicationAccountsRemoveSupportedParams returns a new ApplicationAccountsRemoveSupportedParams
func NewApplicationAccountsRemoveSupportedParams() ApplicationAccountsRemoveSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["userId"] = true
	params["accountId"] = true
	return ApplicationAccountsRemoveSupportedParams{
		params: params,
	}
}

func (sp *ApplicationAccountsRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationAccountsRemove handles ApplicationAccountsRemove request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationAccountsRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationAccountsRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	userIdRawValue := params["userId"]
	// Conversions

	userIdValue := userIdRawValue
	// Data retrieval
	accountIdRawValue := params["accountId"]
	// Conversions

	accountIdValue := accountIdRawValue
	reqData := ApplicationAccountsRemoveRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserId = userIdValue
	reqData.AccountId = accountIdValue

	response, adaptError := handler.adapter.AdaptApplicationAccountsRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}

// ApplicationUsersCreateSupportedParams ApplicationUsersCreate supported parameters
type ApplicationUsersCreateSupportedParams struct {
	params map[string]bool
}

// NewApplicationUsersCreateSupportedParams returns a new ApplicationUsersCreateSupportedParams
func NewApplicationUsersCreateSupportedParams() ApplicationUsersCreateSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["UserCreation"] = true
	return ApplicationUsersCreateSupportedParams{
		params: params,
	}
}

func (sp *ApplicationUsersCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationUsersCreate handles ApplicationUsersCreate request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationUsersCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationUsersCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	userCreationValue := UserCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&userCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	userCreationValidationResult, userCreationValidationErr := userCreationValue.ValidateWith()

	if userCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, userCreationValidationErr)
		return
	}

	if !userCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, userCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	userCreationValue.SetDefaults()
	reqData := ApplicationUsersCreateRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserCreation = userCreationValue

	response, adaptError := handler.adapter.AdaptApplicationUsersCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}

// ApplicationUsersDescribeSupportedParams ApplicationUsersDescribe supported parameters
type ApplicationUsersDescribeSupportedParams struct {
	params map[string]bool
}

// NewApplicationUsersDescribeSupportedParams returns a new ApplicationUsersDescribeSupportedParams
func NewApplicationUsersDescribeSupportedParams() ApplicationUsersDescribeSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["userId"] = true
	return ApplicationUsersDescribeSupportedParams{
		params: params,
	}
}

func (sp *ApplicationUsersDescribeSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationUsersDescribe handles ApplicationUsersDescribe request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationUsersDescribe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationUsersDescribeSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	userIdRawValue := params["userId"]
	// Conversions

	userIdValue := userIdRawValue
	reqData := ApplicationUsersDescribeRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserId = userIdValue

	response, adaptError := handler.adapter.AdaptApplicationUsersDescribe(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}

// ApplicationUsersEditSupportedParams ApplicationUsersEdit supported parameters
type ApplicationUsersEditSupportedParams struct {
	params map[string]bool
}

// NewApplicationUsersEditSupportedParams returns a new ApplicationUsersEditSupportedParams
func NewApplicationUsersEditSupportedParams() ApplicationUsersEditSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["userId"] = true
	params["UserUpdate"] = true
	return ApplicationUsersEditSupportedParams{
		params: params,
	}
}

func (sp *ApplicationUsersEditSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationUsersEdit handles ApplicationUsersEdit request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationUsersEdit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationUsersEditSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	userIdRawValue := params["userId"]
	// Conversions

	userIdValue := userIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	userUpdateValue := UserUpdate{}
	errDecoder := json.NewDecoder(r.Body).Decode(&userUpdateValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	userUpdateValidationResult, userUpdateValidationErr := userUpdateValue.ValidateWith()

	if userUpdateValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, userUpdateValidationErr)
		return
	}

	if !userUpdateValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, userUpdateValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	userUpdateValue.SetDefaults()
	reqData := ApplicationUsersEditRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserId = userIdValue
	reqData.UserUpdate = userUpdateValue

	response, adaptError := handler.adapter.AdaptApplicationUsersEdit(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}

// ApplicationUsersListSupportedParams ApplicationUsersList supported parameters
type ApplicationUsersListSupportedParams struct {
	params map[string]bool
}

// NewApplicationUsersListSupportedParams returns a new ApplicationUsersListSupportedParams
func NewApplicationUsersListSupportedParams() ApplicationUsersListSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["limit"] = true
	params["offset"] = true
	params["orderBy"] = true
	params["orderDirection"] = true
	return ApplicationUsersListSupportedParams{
		params: params,
	}
}

func (sp *ApplicationUsersListSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationUsersList handles ApplicationUsersList request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationUsersList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)
	query := r.URL.Query()

	// Parameters supported check
	supportedParams := NewApplicationUsersListSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	limitRawValue := query.Get("limit")
	limitIsPresent := query.Has("limit")
	// Conversions
	var limitValue *int32
	if limitIsPresent {
		limitToInt, limitConversionErr := toInt32(limitRawValue, "limit")
		if limitConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, limitConversionErr)
			return
		}
		limitValue = new(int32)
		*limitValue = limitToInt
	}
	// Data retrieval
	offsetRawValue := query.Get("offset")
	offsetIsPresent := query.Has("offset")
	// Conversions
	var offsetValue *int32
	if offsetIsPresent {
		offsetToInt, offsetConversionErr := toInt32(offsetRawValue, "offset")
		if offsetConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, offsetConversionErr)
			return
		}
		offsetValue = new(int32)
		*offsetValue = offsetToInt
	}
	// Data retrieval
	orderByRawValue := query.Get("orderBy")
	// Conversions

	orderByValue := orderByRawValue
	// Data retrieval
	orderDirectionRawValue := query.Get("orderDirection")
	// Conversions

	orderDirectionValue := orderDirectionRawValue
	reqData := ApplicationUsersListRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.Limit = limitValue
	reqData.Offset = offsetValue
	reqData.OrderBy = orderByValue
	reqData.OrderDirection = orderDirectionValue

	response, adaptError := handler.adapter.AdaptApplicationUsersList(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserCollection.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserCollection)
}

// ApplicationUsersRemoveSupportedParams ApplicationUsersRemove supported parameters
type ApplicationUsersRemoveSupportedParams struct {
	params map[string]bool
}

// NewApplicationUsersRemoveSupportedParams returns a new ApplicationUsersRemoveSupportedParams
func NewApplicationUsersRemoveSupportedParams() ApplicationUsersRemoveSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["userId"] = true
	return ApplicationUsersRemoveSupportedParams{
		params: params,
	}
}

func (sp *ApplicationUsersRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPApplicationUsersRemove handles ApplicationUsersRemove request
func (handler DefaultApplicationAPIHTTPHandler) HandleHTTPApplicationUsersRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewApplicationUsersRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	userIdRawValue := params["userId"]
	// Conversions

	userIdValue := userIdRawValue
	reqData := ApplicationUsersRemoveRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.UserId = userIdValue

	response, adaptError := handler.adapter.AdaptApplicationUsersRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.UserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.UserDetail)
}
