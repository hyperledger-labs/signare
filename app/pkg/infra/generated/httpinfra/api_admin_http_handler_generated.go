// Code generated by Signare OpenAPI generator. DO NOT EDIT

package httpinfra

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"github.com/hyperledger-labs/signare/app/pkg/infra/httpinfra"

	"github.com/hyperledger-labs/signare/app/pkg/commons/logger"

	"github.com/gorilla/mux"
)

// AdminAPIHTTPHandler functionality to handle AdminAPI HTTP requests
type AdminAPIHTTPHandler interface {

	// HandleHTTPAdminApplicationsCreate handles an AdminApplicationsCreate request
	HandleHTTPAdminApplicationsCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminApplicationsDescribe handles an AdminApplicationsDescribe request
	HandleHTTPAdminApplicationsDescribe(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminApplicationsEdit handles an AdminApplicationsEdit request
	HandleHTTPAdminApplicationsEdit(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminApplicationsList handles an AdminApplicationsList request
	HandleHTTPAdminApplicationsList(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminApplicationsRemove handles an AdminApplicationsRemove request
	HandleHTTPAdminApplicationsRemove(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminModulesCreate handles an AdminModulesCreate request
	HandleHTTPAdminModulesCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminModulesDescribe handles an AdminModulesDescribe request
	HandleHTTPAdminModulesDescribe(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminModulesEdit handles an AdminModulesEdit request
	HandleHTTPAdminModulesEdit(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminModulesList handles an AdminModulesList request
	HandleHTTPAdminModulesList(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminModulesRemove handles an AdminModulesRemove request
	HandleHTTPAdminModulesRemove(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminSlotsCreate handles an AdminSlotsCreate request
	HandleHTTPAdminSlotsCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminSlotsDescribe handles an AdminSlotsDescribe request
	HandleHTTPAdminSlotsDescribe(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminSlotsList handles an AdminSlotsList request
	HandleHTTPAdminSlotsList(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminSlotsRemove handles an AdminSlotsRemove request
	HandleHTTPAdminSlotsRemove(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminSlotsUpdatePin handles an AdminSlotsUpdatePin request
	HandleHTTPAdminSlotsUpdatePin(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminUsersCreate handles an AdminUsersCreate request
	HandleHTTPAdminUsersCreate(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminUsersDescribe handles an AdminUsersDescribe request
	HandleHTTPAdminUsersDescribe(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminUsersEdit handles an AdminUsersEdit request
	HandleHTTPAdminUsersEdit(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminUsersList handles an AdminUsersList request
	HandleHTTPAdminUsersList(responseWriter http.ResponseWriter, request *http.Request)

	// HandleHTTPAdminUsersRemove handles an AdminUsersRemove request
	HandleHTTPAdminUsersRemove(responseWriter http.ResponseWriter, request *http.Request)
}

type AdminAPIAdapter interface {
	AdaptAdminApplicationsCreate(ctx context.Context, data AdminApplicationsCreateRequest) (*AdminApplicationsCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminApplicationsDescribe(ctx context.Context, data AdminApplicationsDescribeRequest) (*AdminApplicationsDescribeResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminApplicationsEdit(ctx context.Context, data AdminApplicationsEditRequest) (*AdminApplicationsEditResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminApplicationsList(ctx context.Context, data AdminApplicationsListRequest) (*AdminApplicationsListResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminApplicationsRemove(ctx context.Context, data AdminApplicationsRemoveRequest) (*AdminApplicationsRemoveResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminModulesCreate(ctx context.Context, data AdminModulesCreateRequest) (*AdminModulesCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminModulesDescribe(ctx context.Context, data AdminModulesDescribeRequest) (*AdminModulesDescribeResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminModulesEdit(ctx context.Context, data AdminModulesEditRequest) (*AdminModulesEditResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminModulesList(ctx context.Context, data AdminModulesListRequest) (*AdminModulesListResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminModulesRemove(ctx context.Context, data AdminModulesRemoveRequest) (*AdminModulesRemoveResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminSlotsCreate(ctx context.Context, data AdminSlotsCreateRequest) (*AdminSlotsCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminSlotsDescribe(ctx context.Context, data AdminSlotsDescribeRequest) (*AdminSlotsDescribeResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminSlotsList(ctx context.Context, data AdminSlotsListRequest) (*AdminSlotsListResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminSlotsRemove(ctx context.Context, data AdminSlotsRemoveRequest) (*AdminSlotsRemoveResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminSlotsUpdatePin(ctx context.Context, data AdminSlotsUpdatePinRequest) (*AdminSlotsUpdatePinResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminUsersCreate(ctx context.Context, data AdminUsersCreateRequest) (*AdminUsersCreateResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminUsersDescribe(ctx context.Context, data AdminUsersDescribeRequest) (*AdminUsersDescribeResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminUsersEdit(ctx context.Context, data AdminUsersEditRequest) (*AdminUsersEditResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminUsersList(ctx context.Context, data AdminUsersListRequest) (*AdminUsersListResponseWrapper, *httpinfra.HTTPError)

	AdaptAdminUsersRemove(ctx context.Context, data AdminUsersRemoveRequest) (*AdminUsersRemoveResponseWrapper, *httpinfra.HTTPError)
}

var _ AdminAPIHTTPHandler = (*DefaultAdminAPIHTTPHandler)(nil)

// DefaultAdminAPIHTTPHandler implementation of AdminAPIHTTPHandler
type DefaultAdminAPIHTTPHandler struct {
	adapter         AdminAPIAdapter
	responseHandler httpinfra.HTTPResponseHandler
}

// DefaultAdminAPIHTTPHandlerOptions options to create a DefaultAdminAPIHTTPHandler
type DefaultAdminAPIHTTPHandlerOptions struct {
	Adapter         AdminAPIAdapter
	ResponseHandler httpinfra.HTTPResponseHandler
}

// NewDefaultAdminAPIHTTPHandler returns a new DefaultAdminAPIHTTPHandler
func NewDefaultAdminAPIHTTPHandler(options DefaultAdminAPIHTTPHandlerOptions) (*DefaultAdminAPIHTTPHandler, error) {
	if options.Adapter == nil {
		return nil, errors.New("adapter field is mandatory")
	}
	if options.ResponseHandler == nil {
		return nil, errors.New("responseHandler field is mandatory")
	}

	return &DefaultAdminAPIHTTPHandler{
		adapter:         options.Adapter,
		responseHandler: options.ResponseHandler,
	}, nil

}

// AdminApplicationsCreateSupportedParams AdminApplicationsCreate supported parameters
type AdminApplicationsCreateSupportedParams struct {
	params map[string]bool
}

// NewAdminApplicationsCreateSupportedParams returns a new AdminApplicationsCreateSupportedParams
func NewAdminApplicationsCreateSupportedParams() AdminApplicationsCreateSupportedParams {
	params := make(map[string]bool)
	params["ApplicationCreation"] = true
	return AdminApplicationsCreateSupportedParams{
		params: params,
	}
}

func (sp *AdminApplicationsCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminApplicationsCreate handles AdminApplicationsCreate request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminApplicationsCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameters supported check
	supportedParams := NewAdminApplicationsCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	// Conversions
	// Request body processing
	applicationCreationValue := ApplicationCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&applicationCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	applicationCreationValidationResult, applicationCreationValidationErr := applicationCreationValue.ValidateWith()

	if applicationCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, applicationCreationValidationErr)
		return
	}

	if !applicationCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, applicationCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	applicationCreationValue.SetDefaults()
	reqData := AdminApplicationsCreateRequest{}
	reqData.ApplicationCreation = applicationCreationValue

	response, adaptError := handler.adapter.AdaptAdminApplicationsCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ApplicationDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ApplicationDetail)
}

// AdminApplicationsDescribeSupportedParams AdminApplicationsDescribe supported parameters
type AdminApplicationsDescribeSupportedParams struct {
	params map[string]bool
}

// NewAdminApplicationsDescribeSupportedParams returns a new AdminApplicationsDescribeSupportedParams
func NewAdminApplicationsDescribeSupportedParams() AdminApplicationsDescribeSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	return AdminApplicationsDescribeSupportedParams{
		params: params,
	}
}

func (sp *AdminApplicationsDescribeSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminApplicationsDescribe handles AdminApplicationsDescribe request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminApplicationsDescribe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminApplicationsDescribeSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	reqData := AdminApplicationsDescribeRequest{}
	reqData.ApplicationId = applicationIdValue

	response, adaptError := handler.adapter.AdaptAdminApplicationsDescribe(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ApplicationDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ApplicationDetail)
}

// AdminApplicationsEditSupportedParams AdminApplicationsEdit supported parameters
type AdminApplicationsEditSupportedParams struct {
	params map[string]bool
}

// NewAdminApplicationsEditSupportedParams returns a new AdminApplicationsEditSupportedParams
func NewAdminApplicationsEditSupportedParams() AdminApplicationsEditSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	params["ApplicationUpdate"] = true
	return AdminApplicationsEditSupportedParams{
		params: params,
	}
}

func (sp *AdminApplicationsEditSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminApplicationsEdit handles AdminApplicationsEdit request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminApplicationsEdit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminApplicationsEditSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	applicationUpdateValue := ApplicationUpdate{}
	errDecoder := json.NewDecoder(r.Body).Decode(&applicationUpdateValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	applicationUpdateValidationResult, applicationUpdateValidationErr := applicationUpdateValue.ValidateWith()

	if applicationUpdateValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, applicationUpdateValidationErr)
		return
	}

	if !applicationUpdateValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, applicationUpdateValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	applicationUpdateValue.SetDefaults()
	reqData := AdminApplicationsEditRequest{}
	reqData.ApplicationId = applicationIdValue
	reqData.ApplicationUpdate = applicationUpdateValue

	response, adaptError := handler.adapter.AdaptAdminApplicationsEdit(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ApplicationDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ApplicationDetail)
}

// AdminApplicationsListSupportedParams AdminApplicationsList supported parameters
type AdminApplicationsListSupportedParams struct {
	params map[string]bool
}

// NewAdminApplicationsListSupportedParams returns a new AdminApplicationsListSupportedParams
func NewAdminApplicationsListSupportedParams() AdminApplicationsListSupportedParams {
	params := make(map[string]bool)
	params["limit"] = true
	params["offset"] = true
	params["orderBy"] = true
	params["orderDirection"] = true
	return AdminApplicationsListSupportedParams{
		params: params,
	}
}

func (sp *AdminApplicationsListSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminApplicationsList handles AdminApplicationsList request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminApplicationsList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	query := r.URL.Query()

	// Parameters supported check
	supportedParams := NewAdminApplicationsListSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	limitRawValue := query.Get("limit")
	limitIsPresent := query.Has("limit")
	// Conversions
	var limitValue *int32
	if limitIsPresent {
		limitToInt, limitConversionErr := toInt32(limitRawValue, "limit")
		if limitConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, limitConversionErr)
			return
		}
		limitValue = new(int32)
		*limitValue = limitToInt
	}
	// Data retrieval
	offsetRawValue := query.Get("offset")
	offsetIsPresent := query.Has("offset")
	// Conversions
	var offsetValue *int32
	if offsetIsPresent {
		offsetToInt, offsetConversionErr := toInt32(offsetRawValue, "offset")
		if offsetConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, offsetConversionErr)
			return
		}
		offsetValue = new(int32)
		*offsetValue = offsetToInt
	}
	// Data retrieval
	orderByRawValue := query.Get("orderBy")
	// Conversions

	orderByValue := orderByRawValue
	// Data retrieval
	orderDirectionRawValue := query.Get("orderDirection")
	// Conversions

	orderDirectionValue := orderDirectionRawValue
	reqData := AdminApplicationsListRequest{}
	reqData.Limit = limitValue
	reqData.Offset = offsetValue
	reqData.OrderBy = orderByValue
	reqData.OrderDirection = orderDirectionValue

	response, adaptError := handler.adapter.AdaptAdminApplicationsList(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ApplicationCollection.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ApplicationCollection)
}

// AdminApplicationsRemoveSupportedParams AdminApplicationsRemove supported parameters
type AdminApplicationsRemoveSupportedParams struct {
	params map[string]bool
}

// NewAdminApplicationsRemoveSupportedParams returns a new AdminApplicationsRemoveSupportedParams
func NewAdminApplicationsRemoveSupportedParams() AdminApplicationsRemoveSupportedParams {
	params := make(map[string]bool)
	params["applicationId"] = true
	return AdminApplicationsRemoveSupportedParams{
		params: params,
	}
}

func (sp *AdminApplicationsRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminApplicationsRemove handles AdminApplicationsRemove request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminApplicationsRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminApplicationsRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	applicationIdRawValue := params["applicationId"]
	// Conversions

	applicationIdValue := applicationIdRawValue
	reqData := AdminApplicationsRemoveRequest{}
	reqData.ApplicationId = applicationIdValue

	response, adaptError := handler.adapter.AdaptAdminApplicationsRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ApplicationDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ApplicationDetail)
}

// AdminModulesCreateSupportedParams AdminModulesCreate supported parameters
type AdminModulesCreateSupportedParams struct {
	params map[string]bool
}

// NewAdminModulesCreateSupportedParams returns a new AdminModulesCreateSupportedParams
func NewAdminModulesCreateSupportedParams() AdminModulesCreateSupportedParams {
	params := make(map[string]bool)
	params["ModuleCreation"] = true
	return AdminModulesCreateSupportedParams{
		params: params,
	}
}

func (sp *AdminModulesCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminModulesCreate handles AdminModulesCreate request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminModulesCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameters supported check
	supportedParams := NewAdminModulesCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	// Conversions
	// Request body processing
	moduleCreationValue := ModuleCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&moduleCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	moduleCreationValidationResult, moduleCreationValidationErr := moduleCreationValue.ValidateWith()

	if moduleCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, moduleCreationValidationErr)
		return
	}

	if !moduleCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, moduleCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	moduleCreationValue.SetDefaults()
	reqData := AdminModulesCreateRequest{}
	reqData.ModuleCreation = moduleCreationValue

	response, adaptError := handler.adapter.AdaptAdminModulesCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ModuleDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ModuleDetail)
}

// AdminModulesDescribeSupportedParams AdminModulesDescribe supported parameters
type AdminModulesDescribeSupportedParams struct {
	params map[string]bool
}

// NewAdminModulesDescribeSupportedParams returns a new AdminModulesDescribeSupportedParams
func NewAdminModulesDescribeSupportedParams() AdminModulesDescribeSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	return AdminModulesDescribeSupportedParams{
		params: params,
	}
}

func (sp *AdminModulesDescribeSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminModulesDescribe handles AdminModulesDescribe request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminModulesDescribe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminModulesDescribeSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	reqData := AdminModulesDescribeRequest{}
	reqData.ModuleId = moduleIdValue

	response, adaptError := handler.adapter.AdaptAdminModulesDescribe(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ModuleDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ModuleDetail)
}

// AdminModulesEditSupportedParams AdminModulesEdit supported parameters
type AdminModulesEditSupportedParams struct {
	params map[string]bool
}

// NewAdminModulesEditSupportedParams returns a new AdminModulesEditSupportedParams
func NewAdminModulesEditSupportedParams() AdminModulesEditSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["ModuleUpdate"] = true
	return AdminModulesEditSupportedParams{
		params: params,
	}
}

func (sp *AdminModulesEditSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminModulesEdit handles AdminModulesEdit request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminModulesEdit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminModulesEditSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	moduleUpdateValue := ModuleUpdate{}
	errDecoder := json.NewDecoder(r.Body).Decode(&moduleUpdateValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	moduleUpdateValidationResult, moduleUpdateValidationErr := moduleUpdateValue.ValidateWith()

	if moduleUpdateValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, moduleUpdateValidationErr)
		return
	}

	if !moduleUpdateValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, moduleUpdateValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	moduleUpdateValue.SetDefaults()
	reqData := AdminModulesEditRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.ModuleUpdate = moduleUpdateValue

	response, adaptError := handler.adapter.AdaptAdminModulesEdit(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ModuleDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ModuleDetail)
}

// AdminModulesListSupportedParams AdminModulesList supported parameters
type AdminModulesListSupportedParams struct {
	params map[string]bool
}

// NewAdminModulesListSupportedParams returns a new AdminModulesListSupportedParams
func NewAdminModulesListSupportedParams() AdminModulesListSupportedParams {
	params := make(map[string]bool)
	params["limit"] = true
	params["offset"] = true
	params["orderBy"] = true
	params["orderDirection"] = true
	return AdminModulesListSupportedParams{
		params: params,
	}
}

func (sp *AdminModulesListSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminModulesList handles AdminModulesList request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminModulesList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	query := r.URL.Query()

	// Parameters supported check
	supportedParams := NewAdminModulesListSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	limitRawValue := query.Get("limit")
	limitIsPresent := query.Has("limit")
	// Conversions
	var limitValue *int32
	if limitIsPresent {
		limitToInt, limitConversionErr := toInt32(limitRawValue, "limit")
		if limitConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, limitConversionErr)
			return
		}
		limitValue = new(int32)
		*limitValue = limitToInt
	}
	// Data retrieval
	offsetRawValue := query.Get("offset")
	offsetIsPresent := query.Has("offset")
	// Conversions
	var offsetValue *int32
	if offsetIsPresent {
		offsetToInt, offsetConversionErr := toInt32(offsetRawValue, "offset")
		if offsetConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, offsetConversionErr)
			return
		}
		offsetValue = new(int32)
		*offsetValue = offsetToInt
	}
	// Data retrieval
	orderByRawValue := query.Get("orderBy")
	// Conversions

	orderByValue := orderByRawValue
	// Data retrieval
	orderDirectionRawValue := query.Get("orderDirection")
	// Conversions

	orderDirectionValue := orderDirectionRawValue
	reqData := AdminModulesListRequest{}
	reqData.Limit = limitValue
	reqData.Offset = offsetValue
	reqData.OrderBy = orderByValue
	reqData.OrderDirection = orderDirectionValue

	response, adaptError := handler.adapter.AdaptAdminModulesList(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ModuleCollection.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ModuleCollection)
}

// AdminModulesRemoveSupportedParams AdminModulesRemove supported parameters
type AdminModulesRemoveSupportedParams struct {
	params map[string]bool
}

// NewAdminModulesRemoveSupportedParams returns a new AdminModulesRemoveSupportedParams
func NewAdminModulesRemoveSupportedParams() AdminModulesRemoveSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	return AdminModulesRemoveSupportedParams{
		params: params,
	}
}

func (sp *AdminModulesRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminModulesRemove handles AdminModulesRemove request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminModulesRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminModulesRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	reqData := AdminModulesRemoveRequest{}
	reqData.ModuleId = moduleIdValue

	response, adaptError := handler.adapter.AdaptAdminModulesRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.ModuleDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.ModuleDetail)
}

// AdminSlotsCreateSupportedParams AdminSlotsCreate supported parameters
type AdminSlotsCreateSupportedParams struct {
	params map[string]bool
}

// NewAdminSlotsCreateSupportedParams returns a new AdminSlotsCreateSupportedParams
func NewAdminSlotsCreateSupportedParams() AdminSlotsCreateSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["SlotCreation"] = true
	return AdminSlotsCreateSupportedParams{
		params: params,
	}
}

func (sp *AdminSlotsCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminSlotsCreate handles AdminSlotsCreate request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminSlotsCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminSlotsCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	slotCreationValue := SlotCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&slotCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	slotCreationValidationResult, slotCreationValidationErr := slotCreationValue.ValidateWith()

	if slotCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, slotCreationValidationErr)
		return
	}

	if !slotCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, slotCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	slotCreationValue.SetDefaults()
	reqData := AdminSlotsCreateRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.SlotCreation = slotCreationValue

	response, adaptError := handler.adapter.AdaptAdminSlotsCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.SlotDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.SlotDetail)
}

// AdminSlotsDescribeSupportedParams AdminSlotsDescribe supported parameters
type AdminSlotsDescribeSupportedParams struct {
	params map[string]bool
}

// NewAdminSlotsDescribeSupportedParams returns a new AdminSlotsDescribeSupportedParams
func NewAdminSlotsDescribeSupportedParams() AdminSlotsDescribeSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["slotId"] = true
	return AdminSlotsDescribeSupportedParams{
		params: params,
	}
}

func (sp *AdminSlotsDescribeSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminSlotsDescribe handles AdminSlotsDescribe request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminSlotsDescribe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminSlotsDescribeSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	slotIdRawValue := params["slotId"]
	// Conversions

	slotIdValue := slotIdRawValue
	reqData := AdminSlotsDescribeRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.SlotId = slotIdValue

	response, adaptError := handler.adapter.AdaptAdminSlotsDescribe(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.SlotDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.SlotDetail)
}

// AdminSlotsListSupportedParams AdminSlotsList supported parameters
type AdminSlotsListSupportedParams struct {
	params map[string]bool
}

// NewAdminSlotsListSupportedParams returns a new AdminSlotsListSupportedParams
func NewAdminSlotsListSupportedParams() AdminSlotsListSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["applicationId"] = true
	params["limit"] = true
	params["offset"] = true
	params["orderBy"] = true
	params["orderDirection"] = true
	return AdminSlotsListSupportedParams{
		params: params,
	}
}

func (sp *AdminSlotsListSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminSlotsList handles AdminSlotsList request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminSlotsList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)
	query := r.URL.Query()

	// Parameters supported check
	supportedParams := NewAdminSlotsListSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	applicationIdRawValue := query.Get("applicationId")
	// Conversions

	applicationIdValue := applicationIdRawValue
	// Data retrieval
	limitRawValue := query.Get("limit")
	limitIsPresent := query.Has("limit")
	// Conversions
	var limitValue *int32
	if limitIsPresent {
		limitToInt, limitConversionErr := toInt32(limitRawValue, "limit")
		if limitConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, limitConversionErr)
			return
		}
		limitValue = new(int32)
		*limitValue = limitToInt
	}
	// Data retrieval
	offsetRawValue := query.Get("offset")
	offsetIsPresent := query.Has("offset")
	// Conversions
	var offsetValue *int32
	if offsetIsPresent {
		offsetToInt, offsetConversionErr := toInt32(offsetRawValue, "offset")
		if offsetConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, offsetConversionErr)
			return
		}
		offsetValue = new(int32)
		*offsetValue = offsetToInt
	}
	// Data retrieval
	orderByRawValue := query.Get("orderBy")
	// Conversions

	orderByValue := orderByRawValue
	// Data retrieval
	orderDirectionRawValue := query.Get("orderDirection")
	// Conversions

	orderDirectionValue := orderDirectionRawValue
	reqData := AdminSlotsListRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.ApplicationId = applicationIdValue
	reqData.Limit = limitValue
	reqData.Offset = offsetValue
	reqData.OrderBy = orderByValue
	reqData.OrderDirection = orderDirectionValue

	response, adaptError := handler.adapter.AdaptAdminSlotsList(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.SlotCollection.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.SlotCollection)
}

// AdminSlotsRemoveSupportedParams AdminSlotsRemove supported parameters
type AdminSlotsRemoveSupportedParams struct {
	params map[string]bool
}

// NewAdminSlotsRemoveSupportedParams returns a new AdminSlotsRemoveSupportedParams
func NewAdminSlotsRemoveSupportedParams() AdminSlotsRemoveSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["slotId"] = true
	return AdminSlotsRemoveSupportedParams{
		params: params,
	}
}

func (sp *AdminSlotsRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminSlotsRemove handles AdminSlotsRemove request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminSlotsRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminSlotsRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	slotIdRawValue := params["slotId"]
	// Conversions

	slotIdValue := slotIdRawValue
	reqData := AdminSlotsRemoveRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.SlotId = slotIdValue

	response, adaptError := handler.adapter.AdaptAdminSlotsRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.SlotDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.SlotDetail)
}

// AdminSlotsUpdatePinSupportedParams AdminSlotsUpdatePin supported parameters
type AdminSlotsUpdatePinSupportedParams struct {
	params map[string]bool
}

// NewAdminSlotsUpdatePinSupportedParams returns a new AdminSlotsUpdatePinSupportedParams
func NewAdminSlotsUpdatePinSupportedParams() AdminSlotsUpdatePinSupportedParams {
	params := make(map[string]bool)
	params["moduleId"] = true
	params["slotId"] = true
	params["SlotUpdatePin"] = true
	return AdminSlotsUpdatePinSupportedParams{
		params: params,
	}
}

func (sp *AdminSlotsUpdatePinSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminSlotsUpdatePin handles AdminSlotsUpdatePin request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminSlotsUpdatePin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminSlotsUpdatePinSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	moduleIdRawValue := params["moduleId"]
	// Conversions

	moduleIdValue := moduleIdRawValue
	// Data retrieval
	slotIdRawValue := params["slotId"]
	// Conversions

	slotIdValue := slotIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	slotUpdatePinValue := SlotUpdatePin{}
	errDecoder := json.NewDecoder(r.Body).Decode(&slotUpdatePinValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	slotUpdatePinValidationResult, slotUpdatePinValidationErr := slotUpdatePinValue.ValidateWith()

	if slotUpdatePinValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, slotUpdatePinValidationErr)
		return
	}

	if !slotUpdatePinValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, slotUpdatePinValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	slotUpdatePinValue.SetDefaults()
	reqData := AdminSlotsUpdatePinRequest{}
	reqData.ModuleId = moduleIdValue
	reqData.SlotId = slotIdValue
	reqData.SlotUpdatePin = slotUpdatePinValue

	response, adaptError := handler.adapter.AdaptAdminSlotsUpdatePin(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.SlotDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.SlotDetail)
}

// AdminUsersCreateSupportedParams AdminUsersCreate supported parameters
type AdminUsersCreateSupportedParams struct {
	params map[string]bool
}

// NewAdminUsersCreateSupportedParams returns a new AdminUsersCreateSupportedParams
func NewAdminUsersCreateSupportedParams() AdminUsersCreateSupportedParams {
	params := make(map[string]bool)
	params["AdminUserCreation"] = true
	return AdminUsersCreateSupportedParams{
		params: params,
	}
}

func (sp *AdminUsersCreateSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminUsersCreate handles AdminUsersCreate request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminUsersCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameters supported check
	supportedParams := NewAdminUsersCreateSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	// Conversions
	// Request body processing
	adminUserCreationValue := AdminUserCreation{}
	errDecoder := json.NewDecoder(r.Body).Decode(&adminUserCreationValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	adminUserCreationValidationResult, adminUserCreationValidationErr := adminUserCreationValue.ValidateWith()

	if adminUserCreationValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adminUserCreationValidationErr)
		return
	}

	if !adminUserCreationValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, adminUserCreationValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	adminUserCreationValue.SetDefaults()
	reqData := AdminUsersCreateRequest{}
	reqData.AdminUserCreation = adminUserCreationValue

	response, adaptError := handler.adapter.AdaptAdminUsersCreate(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.AdminUserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.AdminUserDetail)
}

// AdminUsersDescribeSupportedParams AdminUsersDescribe supported parameters
type AdminUsersDescribeSupportedParams struct {
	params map[string]bool
}

// NewAdminUsersDescribeSupportedParams returns a new AdminUsersDescribeSupportedParams
func NewAdminUsersDescribeSupportedParams() AdminUsersDescribeSupportedParams {
	params := make(map[string]bool)
	params["adminUserId"] = true
	return AdminUsersDescribeSupportedParams{
		params: params,
	}
}

func (sp *AdminUsersDescribeSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminUsersDescribe handles AdminUsersDescribe request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminUsersDescribe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminUsersDescribeSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	adminUserIdRawValue := params["adminUserId"]
	// Conversions

	adminUserIdValue := adminUserIdRawValue
	reqData := AdminUsersDescribeRequest{}
	reqData.AdminUserId = adminUserIdValue

	response, adaptError := handler.adapter.AdaptAdminUsersDescribe(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.AdminUserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.AdminUserDetail)
}

// AdminUsersEditSupportedParams AdminUsersEdit supported parameters
type AdminUsersEditSupportedParams struct {
	params map[string]bool
}

// NewAdminUsersEditSupportedParams returns a new AdminUsersEditSupportedParams
func NewAdminUsersEditSupportedParams() AdminUsersEditSupportedParams {
	params := make(map[string]bool)
	params["adminUserId"] = true
	params["AdminUserUpdate"] = true
	return AdminUsersEditSupportedParams{
		params: params,
	}
}

func (sp *AdminUsersEditSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminUsersEdit handles AdminUsersEdit request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminUsersEdit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminUsersEditSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	adminUserIdRawValue := params["adminUserId"]
	// Conversions

	adminUserIdValue := adminUserIdRawValue
	// Data retrieval
	// Conversions
	// Request body processing
	adminUserUpdateValue := AdminUserUpdate{}
	errDecoder := json.NewDecoder(r.Body).Decode(&adminUserUpdateValue)
	if errDecoder != nil {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when parsing the JSON request data [%s]: [%s]", r.Body, errDecoder.Error()))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}
	adminUserUpdateValidationResult, adminUserUpdateValidationErr := adminUserUpdateValue.ValidateWith()

	if adminUserUpdateValidationErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adminUserUpdateValidationErr)
		return
	}

	if !adminUserUpdateValidationResult.Valid {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("an error occurred when validating the JSON request data [%s]: [%s]", r.Body, adminUserUpdateValidationResult.NotValidReason))
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	adminUserUpdateValue.SetDefaults()
	reqData := AdminUsersEditRequest{}
	reqData.AdminUserId = adminUserIdValue
	reqData.AdminUserUpdate = adminUserUpdateValue

	response, adaptError := handler.adapter.AdaptAdminUsersEdit(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.AdminUserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.AdminUserDetail)
}

// AdminUsersListSupportedParams AdminUsersList supported parameters
type AdminUsersListSupportedParams struct {
	params map[string]bool
}

// NewAdminUsersListSupportedParams returns a new AdminUsersListSupportedParams
func NewAdminUsersListSupportedParams() AdminUsersListSupportedParams {
	params := make(map[string]bool)
	params["limit"] = true
	params["offset"] = true
	params["orderBy"] = true
	params["orderDirection"] = true
	return AdminUsersListSupportedParams{
		params: params,
	}
}

func (sp *AdminUsersListSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminUsersList handles AdminUsersList request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminUsersList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	query := r.URL.Query()

	// Parameters supported check
	supportedParams := NewAdminUsersListSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	limitRawValue := query.Get("limit")
	limitIsPresent := query.Has("limit")
	// Conversions
	var limitValue *int32
	if limitIsPresent {
		limitToInt, limitConversionErr := toInt32(limitRawValue, "limit")
		if limitConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, limitConversionErr)
			return
		}
		limitValue = new(int32)
		*limitValue = limitToInt
	}
	// Data retrieval
	offsetRawValue := query.Get("offset")
	offsetIsPresent := query.Has("offset")
	// Conversions
	var offsetValue *int32
	if offsetIsPresent {
		offsetToInt, offsetConversionErr := toInt32(offsetRawValue, "offset")
		if offsetConversionErr != nil {
			handler.responseHandler.HandleErrorResponse(ctx, w, offsetConversionErr)
			return
		}
		offsetValue = new(int32)
		*offsetValue = offsetToInt
	}
	// Data retrieval
	orderByRawValue := query.Get("orderBy")
	// Conversions

	orderByValue := orderByRawValue
	// Data retrieval
	orderDirectionRawValue := query.Get("orderDirection")
	// Conversions

	orderDirectionValue := orderDirectionRawValue
	reqData := AdminUsersListRequest{}
	reqData.Limit = limitValue
	reqData.Offset = offsetValue
	reqData.OrderBy = orderByValue
	reqData.OrderDirection = orderDirectionValue

	response, adaptError := handler.adapter.AdaptAdminUsersList(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.AdminUserCollection.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.AdminUserCollection)
}

// AdminUsersRemoveSupportedParams AdminUsersRemove supported parameters
type AdminUsersRemoveSupportedParams struct {
	params map[string]bool
}

// NewAdminUsersRemoveSupportedParams returns a new AdminUsersRemoveSupportedParams
func NewAdminUsersRemoveSupportedParams() AdminUsersRemoveSupportedParams {
	params := make(map[string]bool)
	params["adminUserId"] = true
	return AdminUsersRemoveSupportedParams{
		params: params,
	}
}

func (sp *AdminUsersRemoveSupportedParams) check(r *http.Request) *httpinfra.HTTPError {
	unsupportedParams := make([]string, 0)
	queryParams := r.URL.Query()
	for param := range queryParams {
		if !sp.params[param] {
			unsupportedParams = append(unsupportedParams, param)
		}
	}
	if len(unsupportedParams) > 0 {
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage(fmt.Sprintf("Unsupported parameters in request [%s]", strings.Join(unsupportedParams, ",")))
		return httpError
	}
	return nil
}

// HandleHTTPAdminUsersRemove handles AdminUsersRemove request
func (handler DefaultAdminAPIHTTPHandler) HandleHTTPAdminUsersRemove(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	params := mux.Vars(r)

	// Parameters supported check
	supportedParams := NewAdminUsersRemoveSupportedParams()
	supportedParamsErr := supportedParams.check(r)
	if supportedParamsErr != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, supportedParamsErr)
		return
	}

	// Data retrieval
	adminUserIdRawValue := params["adminUserId"]
	// Conversions

	adminUserIdValue := adminUserIdRawValue
	reqData := AdminUsersRemoveRequest{}
	reqData.AdminUserId = adminUserIdValue

	response, adaptError := handler.adapter.AdaptAdminUsersRemove(ctx, reqData)
	if adaptError != nil {
		handler.responseHandler.HandleErrorResponse(ctx, w, adaptError)
		return
	}

	responseValidationResult, responseValidationErr := response.AdminUserDetail.ValidateWith()

	if responseValidationErr != nil || !responseValidationResult.Valid {
		logger.LogEntry(ctx).Errorf("error validating response [%+v]", response)
		httpError := httpinfra.NewHTTPError(httpinfra.StatusInvalidArgument)
		httpError.SetMessage("the response was not successfully validated")
		handler.responseHandler.HandleErrorResponse(ctx, w, httpError)
		return
	}

	handler.responseHandler.HandleSuccessResponse(ctx, w, response.ResponseInfo, response.AdminUserDetail)
}
